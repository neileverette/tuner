---
phase: 09-sort-state-logic
plan: 01
type: execute
domain: frontend
---

<objective>
Create sorting state management and utility functions for all three sort modes.

Purpose: Establish the sorting infrastructure that Phase 10 (Sort Dropdown UI) and Phase 11 (Apply Sorting to Views) will build upon. This includes defining sort types, implementing sort functions, and adding sort state to App.tsx.

Output: New `src/utils/sorting.ts` module with typed sorting utilities, `SortOption` type exported from types, and sort state initialized in App.tsx.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-phase.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

**Key types (from src/types/channel.ts):**
```typescript
export type Channel = {
  id: string;
  sourceId: string;
  source: SourceType;
  title: string;
  description: string;
  genre: string;
  dj: string | null;
  image: { small: string; medium: string; large: string };
  streams: StreamQuality[];
  nowPlaying: NowPlaying | null;
  listeners: number | null;  // Radio Paradise channels have null listeners
  homepage: string | null;
};
```

**Sort modes from ROADMAP.md:**
| Option | Sort Logic |
|--------|-----------|
| Station | Alphabetical by `channel.title` |
| Genre | Alphabetical by `channel.genre`, then `channel.title` |
| Popularity | Descending by `channel.listeners` (null to top) |

**Critical requirement:** Radio Paradise channels have `listeners: null` and should sort to the TOP when sorting by popularity (they are premium quality streams).

**Files to modify:**
@src/types/index.ts (add SortOption export)
@src/App.tsx (add sort state)

**Files to create:**
- src/types/sorting.ts (SortOption type)
- src/utils/sorting.ts (sorting utilities)

**Established patterns (from project conventions):**
- Types in src/types/
- Utility functions in src/utils/
- Default export for components, named exports for utilities
- camelCase for functions
- PascalCase for types
</context>

<tasks>
<task type="auto">
  <name>Task 1: Create SortOption type</name>
  <files>
    src/types/sorting.ts (create)
    src/types/index.ts (modify)
  </files>
  <action>
Create `src/types/sorting.ts` with:

```typescript
/**
 * Available sorting options for channel lists
 */
export type SortOption = 'station' | 'genre' | 'popularity';

/**
 * Default sort option
 */
export const DEFAULT_SORT: SortOption = 'station';
```

Update `src/types/index.ts` to add:

```typescript
export type { SortOption } from './sorting';
export { DEFAULT_SORT } from './sorting';
```

  </action>
  <verify>
    - `npm run build` succeeds without errors
    - File exists: src/types/sorting.ts
    - SortOption is exported from src/types/index.ts
  </verify>
  <done>
    - SortOption type defined with three options
    - DEFAULT_SORT constant exported
    - Types re-exported from index.ts
  </done>
</task>

<task type="auto">
  <name>Task 2: Create sorting utilities</name>
  <files>
    src/utils/sorting.ts (create)
  </files>
  <action>
Create `src/utils/` directory if it doesn't exist.

Create `src/utils/sorting.ts` with:

```typescript
import type { Channel } from '../types';
import type { SortOption } from '../types';

/**
 * Compare function for alphabetical string sorting (case-insensitive)
 */
function compareStrings(a: string, b: string): number {
  return a.toLowerCase().localeCompare(b.toLowerCase());
}

/**
 * Sort channels by station name (alphabetical by title)
 */
function sortByStation(channels: Channel[]): Channel[] {
  return [...channels].sort((a, b) => compareStrings(a.title, b.title));
}

/**
 * Sort channels by genre (alphabetical by genre, then by title)
 */
function sortByGenre(channels: Channel[]): Channel[] {
  return [...channels].sort((a, b) => {
    const genreCompare = compareStrings(a.genre, b.genre);
    if (genreCompare !== 0) return genreCompare;
    return compareStrings(a.title, b.title);
  });
}

/**
 * Sort channels by popularity (listeners descending, null values to top)
 *
 * Radio Paradise channels have null listeners and should appear at the top
 * since they are premium quality streams without listener counts.
 */
function sortByPopularity(channels: Channel[]): Channel[] {
  return [...channels].sort((a, b) => {
    // null values go to top (most valuable)
    if (a.listeners === null && b.listeners === null) {
      // Both null: secondary sort by title
      return compareStrings(a.title, b.title);
    }
    if (a.listeners === null) return -1;  // a goes first
    if (b.listeners === null) return 1;   // b goes first

    // Both have values: sort descending (higher listeners first)
    const diff = b.listeners - a.listeners;
    if (diff !== 0) return diff;

    // Same listener count: secondary sort by title
    return compareStrings(a.title, b.title);
  });
}

/**
 * Sort channels by the specified sort option
 *
 * @param channels - Array of channels to sort
 * @param sortOption - The sorting mode to apply
 * @returns New sorted array (original not mutated)
 */
export function sortChannels(channels: Channel[], sortOption: SortOption): Channel[] {
  switch (sortOption) {
    case 'station':
      return sortByStation(channels);
    case 'genre':
      return sortByGenre(channels);
    case 'popularity':
      return sortByPopularity(channels);
    default:
      // Exhaustive check - TypeScript will error if a case is missing
      const _exhaustive: never = sortOption;
      return channels;
  }
}

/**
 * Get display label for a sort option
 */
export function getSortLabel(sortOption: SortOption): string {
  switch (sortOption) {
    case 'station':
      return 'Station';
    case 'genre':
      return 'Genre';
    case 'popularity':
      return 'Popularity';
  }
}

/**
 * All available sort options in display order
 */
export const SORT_OPTIONS: SortOption[] = ['station', 'genre', 'popularity'];
```

  </action>
  <verify>
    - `npm run build` succeeds without errors
    - `npm run lint` passes
    - File exists: src/utils/sorting.ts
    - All functions are properly typed
  </verify>
  <done>
    - sortChannels() function handles all three sort modes
    - sortByPopularity() correctly puts null listeners at top
    - getSortLabel() provides display text
    - SORT_OPTIONS array exported for dropdown use
    - All functions return new arrays (immutable)
  </done>
</task>

<task type="auto">
  <name>Task 3: Create utils index file</name>
  <files>
    src/utils/index.ts (create)
  </files>
  <action>
Create `src/utils/index.ts` to establish the utils module pattern:

```typescript
export {
  sortChannels,
  getSortLabel,
  SORT_OPTIONS,
} from './sorting';
```

This establishes the utils barrel export pattern for future utilities.
  </action>
  <verify>
    - File exists: src/utils/index.ts
    - `npm run build` succeeds
    - Exports are accessible via `import { sortChannels } from './utils'`
  </verify>
  <done>
    - Utils index file created
    - Sorting utilities re-exported
  </done>
</task>

<task type="auto">
  <name>Task 4: Add sort state to App.tsx</name>
  <files>
    src/App.tsx (modify)
  </files>
  <action>
Add sort state to App.tsx. This prepares for Phase 10 (dropdown UI) and Phase 11 (applying sort).

**Add import at top of file:**
```typescript
import type { SortOption } from './types'
import { DEFAULT_SORT } from './types'
```

**Add state after existing state declarations (around line 18, after selectedIndex):**
```typescript
const [sortOption, setSortOption] = useState<SortOption>(DEFAULT_SORT)
```

**Note:** Do NOT apply sorting yet - that happens in Phase 11. This task only adds the state variable.

The state will be used by:
- Phase 10: SortDropdown component will call setSortOption
- Phase 11: Channels will be sorted before passing to ChannelCarousel and StationPicker
  </action>
  <verify>
    - `npm run build` succeeds without errors
    - `npm run lint` passes
    - App.tsx imports SortOption type and DEFAULT_SORT
    - App.tsx has sortOption state initialized to 'station'
  </verify>
  <done>
    - sortOption state added to App.tsx
    - setSortOption handler available for Phase 10
    - Default value is 'station' (alphabetical by name)
  </done>
</task>

<task type="auto">
  <name>Task 5: Create unit tests for sorting utilities</name>
  <files>
    src/utils/sorting.test.ts (create)
  </files>
  <action>
Create `src/utils/sorting.test.ts` with comprehensive tests:

```typescript
import { describe, it, expect } from 'vitest';
import { sortChannels, getSortLabel, SORT_OPTIONS } from './sorting';
import type { Channel } from '../types';

// Minimal channel factory for testing
function createChannel(overrides: Partial<Channel>): Channel {
  return {
    id: 'test:channel',
    sourceId: 'channel',
    source: 'somafm',
    title: 'Test Channel',
    description: 'A test channel',
    genre: 'Test',
    dj: null,
    image: { small: '', medium: '', large: '' },
    streams: [],
    nowPlaying: null,
    listeners: 100,
    homepage: null,
    ...overrides,
  };
}

describe('sortChannels', () => {
  describe('station sort (alphabetical by title)', () => {
    it('sorts channels alphabetically by title', () => {
      const channels = [
        createChannel({ id: '1', title: 'Groove Salad' }),
        createChannel({ id: '2', title: 'Drone Zone' }),
        createChannel({ id: '3', title: 'Ambient' }),
      ];

      const sorted = sortChannels(channels, 'station');

      expect(sorted.map(c => c.title)).toEqual([
        'Ambient',
        'Drone Zone',
        'Groove Salad',
      ]);
    });

    it('is case-insensitive', () => {
      const channels = [
        createChannel({ id: '1', title: 'UPPERCASE' }),
        createChannel({ id: '2', title: 'lowercase' }),
        createChannel({ id: '3', title: 'MixedCase' }),
      ];

      const sorted = sortChannels(channels, 'station');

      expect(sorted.map(c => c.title)).toEqual([
        'lowercase',
        'MixedCase',
        'UPPERCASE',
      ]);
    });

    it('does not mutate original array', () => {
      const channels = [
        createChannel({ id: '1', title: 'B' }),
        createChannel({ id: '2', title: 'A' }),
      ];
      const original = [...channels];

      sortChannels(channels, 'station');

      expect(channels).toEqual(original);
    });
  });

  describe('genre sort (by genre, then title)', () => {
    it('sorts by genre first, then by title within genre', () => {
      const channels = [
        createChannel({ id: '1', title: 'Station B', genre: 'Rock' }),
        createChannel({ id: '2', title: 'Station A', genre: 'Rock' }),
        createChannel({ id: '3', title: 'Station C', genre: 'Jazz' }),
      ];

      const sorted = sortChannels(channels, 'genre');

      expect(sorted.map(c => `${c.genre}:${c.title}`)).toEqual([
        'Jazz:Station C',
        'Rock:Station A',
        'Rock:Station B',
      ]);
    });
  });

  describe('popularity sort (by listeners descending, null to top)', () => {
    it('sorts by listeners descending', () => {
      const channels = [
        createChannel({ id: '1', title: 'Low', listeners: 50 }),
        createChannel({ id: '2', title: 'High', listeners: 500 }),
        createChannel({ id: '3', title: 'Medium', listeners: 200 }),
      ];

      const sorted = sortChannels(channels, 'popularity');

      expect(sorted.map(c => c.listeners)).toEqual([500, 200, 50]);
    });

    it('puts null listeners at the top (Radio Paradise)', () => {
      const channels = [
        createChannel({ id: '1', title: 'SomaFM Low', listeners: 50, source: 'somafm' }),
        createChannel({ id: '2', title: 'Radio Paradise', listeners: null, source: 'radioparadise' }),
        createChannel({ id: '3', title: 'SomaFM High', listeners: 500, source: 'somafm' }),
      ];

      const sorted = sortChannels(channels, 'popularity');

      expect(sorted[0].title).toBe('Radio Paradise');
      expect(sorted[0].listeners).toBe(null);
    });

    it('sorts multiple null listeners by title', () => {
      const channels = [
        createChannel({ id: '1', title: 'RP Rock', listeners: null }),
        createChannel({ id: '2', title: 'RP Main', listeners: null }),
        createChannel({ id: '3', title: 'RP Mellow', listeners: null }),
      ];

      const sorted = sortChannels(channels, 'popularity');

      expect(sorted.map(c => c.title)).toEqual([
        'RP Main',
        'RP Mellow',
        'RP Rock',
      ]);
    });

    it('uses title as tiebreaker for equal listener counts', () => {
      const channels = [
        createChannel({ id: '1', title: 'Station B', listeners: 100 }),
        createChannel({ id: '2', title: 'Station A', listeners: 100 }),
      ];

      const sorted = sortChannels(channels, 'popularity');

      expect(sorted.map(c => c.title)).toEqual(['Station A', 'Station B']);
    });
  });

  describe('empty array handling', () => {
    it('returns empty array for empty input', () => {
      expect(sortChannels([], 'station')).toEqual([]);
      expect(sortChannels([], 'genre')).toEqual([]);
      expect(sortChannels([], 'popularity')).toEqual([]);
    });
  });

  describe('single item handling', () => {
    it('returns single-item array unchanged', () => {
      const channels = [createChannel({ id: '1', title: 'Only One' })];

      expect(sortChannels(channels, 'station')).toHaveLength(1);
      expect(sortChannels(channels, 'genre')).toHaveLength(1);
      expect(sortChannels(channels, 'popularity')).toHaveLength(1);
    });
  });
});

describe('getSortLabel', () => {
  it('returns correct labels', () => {
    expect(getSortLabel('station')).toBe('Station');
    expect(getSortLabel('genre')).toBe('Genre');
    expect(getSortLabel('popularity')).toBe('Popularity');
  });
});

describe('SORT_OPTIONS', () => {
  it('contains all three options', () => {
    expect(SORT_OPTIONS).toEqual(['station', 'genre', 'popularity']);
  });
});
```

  </action>
  <verify>
    - `npm run test` or `npm run test -- src/utils/sorting.test.ts` passes
    - All test cases pass
    - Coverage for all sort modes
  </verify>
  <done>
    - Unit tests cover all three sort modes
    - Edge cases tested (empty, single item, null listeners)
    - Null-to-top behavior verified for popularity sort
    - Immutability verified
  </done>
</task>

<task type="checkpoint:human-verify" gate="non-blocking">
  <what-built>Sorting utilities and sort state in App.tsx</what-built>
  <how-to-verify>
    1. Run: `npm run build` - should succeed with no errors
    2. Run: `npm run test -- src/utils/sorting.test.ts` - all tests should pass
    3. Review src/utils/sorting.ts for correct null handling logic
    4. Verify App.tsx has sortOption state (won't be visible in UI yet - that's Phase 10)
  </how-to-verify>
  <resume-signal>Type "approved" to proceed, or describe any issues with the sorting logic</resume-signal>
</task>
</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds without errors
- [ ] `npm run lint` passes
- [ ] `npm run test -- src/utils/sorting.test.ts` passes (all sorting tests)
- [ ] src/types/sorting.ts exists with SortOption type
- [ ] src/utils/sorting.ts exists with sortChannels function
- [ ] src/utils/index.ts exists with barrel exports
- [ ] App.tsx has sortOption state initialized to 'station'
- [ ] No runtime errors when starting dev server
</verification>

<success_criteria>
- SortOption type defined as `'station' | 'genre' | 'popularity'`
- sortChannels() function correctly implements all three sort modes
- Popularity sort puts null listeners (Radio Paradise) at top
- All sorting functions return new arrays (immutable)
- Sort state added to App.tsx (default: 'station')
- Unit tests pass for all sorting scenarios
- Phase 10 can proceed (dropdown will use setSortOption and SORT_OPTIONS)
- Phase 11 can proceed (will apply sortChannels to channel arrays)
</success_criteria>

<output>
After completion, create `.planning/phases/09-sort-state-logic/09-01-SUMMARY.md`:

```markdown
---
phase: 09-sort-state-logic
plan: 01
type: execute
status: complete
---

# Phase 9 Plan 1: Sort State & Logic

**Created sorting infrastructure with type-safe utilities and state management.**

## Accomplishments
- [x] Created SortOption type with three sort modes
- [x] Implemented sortChannels() utility function
- [x] Null listeners (Radio Paradise) sort to top for popularity
- [x] Added sort state to App.tsx
- [x] Comprehensive unit tests for sorting logic

## Files Created
- src/types/sorting.ts (SortOption type, DEFAULT_SORT constant)
- src/utils/sorting.ts (sortChannels, getSortLabel, SORT_OPTIONS)
- src/utils/index.ts (barrel exports)
- src/utils/sorting.test.ts (unit tests)

## Files Modified
- src/types/index.ts (re-export SortOption)
- src/App.tsx (add sortOption state)

## Key Design Decisions
- Null listeners sort to TOP for popularity (Radio Paradise premium streams)
- Case-insensitive alphabetical sorting
- Title used as secondary sort key for stable ordering
- Immutable sorting (original arrays not mutated)

## Next Phase Readiness
Ready for Phase 10 (Sort Dropdown UI):
- SORT_OPTIONS array available for dropdown options
- getSortLabel() for display text
- setSortOption available in App.tsx

Ready for Phase 11 (Apply Sorting to Views):
- sortChannels() ready to sort channel arrays
- sortOption state available for current selection
```
</output>
