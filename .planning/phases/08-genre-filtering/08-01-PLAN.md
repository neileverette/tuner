---
phase: 08-genre-filtering
plan: 01
type: execute
domain: frontend
---

<objective>
Add genre filtering with a dropdown multi-select UI and removable chips.

Purpose: Allow users to filter which stations appear by selecting genres from a dropdown. Selected genres appear as rounded chips with X buttons for easy removal. All genres are enabled by default.

Output: Dropdown multi-select trigger, removable genre chips, filtered channel display, persistent filter state via localStorage.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-phase.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/codebase/CONVENTIONS.md
@.planning/codebase/STRUCTURE.md

**Key source files:**
@src/App.tsx
@src/App.css
@src/config/genres.ts
@src/types/channel.ts

**Existing chip styling to match (from App.css):**
```css
.filter-chip {
  background: rgba(255, 255, 255, 0.1);
  border: 1px solid rgba(255, 255, 255, 0.15);
  border-radius: 16px;
  color: rgba(255, 255, 255, 0.7);
  font-size: 12px;
  font-weight: 500;
  padding: 6px 14px;
  cursor: pointer;
  transition: all 0.15s ease;
}
```

**UI Design Requirements:**
1. Dropdown trigger button that opens a multi-select list
2. ALL genres ON by default (user removes what they don't want)
3. Each enabled genre shows as a rounded chip with X button on right
4. Clicking X removes that genre (filters out those stations)
5. Rounded chip style matching existing `.filter-chip` (16px border-radius, glassmorphic)

**Genre system available:**
- `GENRES` object with 8 categories
- `GenreId` type for type-safe genre identifiers
- `GENRE_LIST` sorted array for iteration
- Source mappings in: `src/config/sources/somafm.ts` and `src/config/sources/radio-paradise.ts`
</context>

<tasks>
<task type="auto">
  <name>Task 1: Create useGenreFilter hook with persistence</name>
  <files>
    src/hooks/useGenreFilter.ts (create)
    src/hooks/index.ts (modify)
  </files>
  <action>
Create `src/hooks/useGenreFilter.ts` with:

```typescript
import { useState, useCallback } from 'react';
import { GENRE_IDS, type GenreId } from '../config/genres';

const STORAGE_KEY = 'tuner-genre-filter';

export type UseGenreFilterResult = {
  enabledGenres: Set<GenreId>;
  isGenreEnabled: (genreId: GenreId) => boolean;
  enableGenre: (genreId: GenreId) => void;
  disableGenre: (genreId: GenreId) => void;
  toggleGenre: (genreId: GenreId) => void;
  enableAll: () => void;
  isFiltering: boolean;  // true if any genres are disabled
  enabledCount: number;
  totalCount: number;
};

function loadFromStorage(): Set<GenreId> {
  try {
    const saved = localStorage.getItem(STORAGE_KEY);
    if (saved) {
      const parsed = JSON.parse(saved) as string[];
      const validIds = parsed.filter((id): id is GenreId =>
        GENRE_IDS.includes(id as GenreId)
      );
      return new Set(validIds);
    }
  } catch {
    // Invalid data, return default
  }
  // Default: all genres enabled
  return new Set(GENRE_IDS);
}

function saveToStorage(genres: Set<GenreId>): void {
  localStorage.setItem(STORAGE_KEY, JSON.stringify([...genres]));
}

export function useGenreFilter(): UseGenreFilterResult {
  const [enabledGenres, setEnabledGenres] = useState<Set<GenreId>>(loadFromStorage);

  const isGenreEnabled = useCallback(
    (genreId: GenreId) => enabledGenres.has(genreId),
    [enabledGenres]
  );

  const enableGenre = useCallback((genreId: GenreId) => {
    setEnabledGenres(prev => {
      if (prev.has(genreId)) return prev;
      const next = new Set(prev);
      next.add(genreId);
      saveToStorage(next);
      return next;
    });
  }, []);

  const disableGenre = useCallback((genreId: GenreId) => {
    setEnabledGenres(prev => {
      if (!prev.has(genreId)) return prev;
      const next = new Set(prev);
      next.delete(genreId);
      saveToStorage(next);
      return next;
    });
  }, []);

  const toggleGenre = useCallback((genreId: GenreId) => {
    setEnabledGenres(prev => {
      const next = new Set(prev);
      if (next.has(genreId)) {
        next.delete(genreId);
      } else {
        next.add(genreId);
      }
      saveToStorage(next);
      return next;
    });
  }, []);

  const enableAll = useCallback(() => {
    const all = new Set(GENRE_IDS);
    setEnabledGenres(all);
    saveToStorage(all);
  }, []);

  return {
    enabledGenres,
    isGenreEnabled,
    enableGenre,
    disableGenre,
    toggleGenre,
    enableAll,
    isFiltering: enabledGenres.size < GENRE_IDS.length,
    enabledCount: enabledGenres.size,
    totalCount: GENRE_IDS.length,
  };
}
```

Export from `src/hooks/index.ts`:
```typescript
export { useGenreFilter } from './useGenreFilter';
export type { UseGenreFilterResult } from './useGenreFilter';
```
  </action>
  <verify>
    - `npm run build` succeeds without errors
    - `npm run lint` passes
    - File exists: src/hooks/useGenreFilter.ts
    - Hook is exported from src/hooks/index.ts
  </verify>
  <done>
    - useGenreFilter hook created with enable/disable/toggle operations
    - localStorage persistence working
    - isFiltering computed property for UI feedback
  </done>
</task>

<task type="auto">
  <name>Task 2: Create channel-to-genre mapping utility</name>
  <files>
    src/utils/genreMapping.ts (create)
    src/utils/index.ts (modify)
  </files>
  <action>
Create `src/utils/genreMapping.ts` to map Channel objects to their normalized GenreId:

```typescript
import type { Channel } from '../types';
import type { GenreId } from '../config/genres';
import { isValidGenreId } from '../config/genres';
import { SOMAFM_CHANNELS } from '../config/sources/somafm';
import { RADIO_PARADISE_CHANNELS } from '../config/sources/radio-paradise';

// Build a lookup map from channel sourceId to primary genre
const CHANNEL_GENRE_MAP: Map<string, GenreId> = new Map();

// Add SomaFM mappings
for (const [channelId, config] of Object.entries(SOMAFM_CHANNELS)) {
  CHANNEL_GENRE_MAP.set(`somafm:${channelId}`, config.genres.primary);
}

// Add Radio Paradise mappings
for (const [channelId, config] of Object.entries(RADIO_PARADISE_CHANNELS)) {
  CHANNEL_GENRE_MAP.set(`radioparadise:${channelId}`, config.genres.primary);
}

/**
 * Get the normalized primary genre for a channel.
 * Falls back to 'eclectic' if no mapping exists.
 */
export function getChannelGenreId(channel: Channel): GenreId {
  const mapped = CHANNEL_GENRE_MAP.get(channel.id);
  if (mapped) return mapped;

  // Fallback: try to match the raw genre string to a genre ID
  const rawGenre = channel.genre.toLowerCase().replace(/[^a-z]/g, '');
  if (isValidGenreId(rawGenre)) return rawGenre;

  // Default fallback
  return 'eclectic';
}

/**
 * Filter channels by enabled genres.
 */
export function filterChannelsByGenre(
  channels: Channel[],
  enabledGenres: Set<GenreId>
): Channel[] {
  if (enabledGenres.size === 0) return [];
  return channels.filter(channel =>
    enabledGenres.has(getChannelGenreId(channel))
  );
}
```

Update `src/utils/index.ts` to export:
```typescript
export { sortChannels } from './sorting';
export { getChannelGenreId, filterChannelsByGenre } from './genreMapping';
```
  </action>
  <verify>
    - `npm run build` succeeds without errors
    - `npm run lint` passes
    - File exists: src/utils/genreMapping.ts
    - Functions exported from src/utils/index.ts
  </verify>
  <done>
    - getChannelGenreId maps any Channel to its GenreId
    - filterChannelsByGenre filters channel array by enabled genres
    - Handles all sources (SomaFM, Radio Paradise)
  </done>
</task>

<task type="auto">
  <name>Task 3: Create GenreFilter component with dropdown and chips</name>
  <files>
    src/components/GenreFilter.tsx (create)
    src/App.css (modify)
  </files>
  <action>
Create `src/components/GenreFilter.tsx`:

```typescript
import { useState, useRef, useEffect } from 'react';
import { GENRE_LIST, type GenreId } from '../config/genres';

type GenreFilterProps = {
  enabledGenres: Set<GenreId>;
  onEnableGenre: (genreId: GenreId) => void;
  onDisableGenre: (genreId: GenreId) => void;
  onEnableAll: () => void;
};

export default function GenreFilter({
  enabledGenres,
  onEnableGenre,
  onDisableGenre,
  onEnableAll,
}: GenreFilterProps) {
  const [dropdownOpen, setDropdownOpen] = useState(false);
  const containerRef = useRef<HTMLDivElement>(null);

  // Get disabled genres (ones that can be added back)
  const disabledGenres = GENRE_LIST.filter(g => !enabledGenres.has(g.id as GenreId));
  // Get enabled genres for chip display
  const enabledGenreList = GENRE_LIST.filter(g => enabledGenres.has(g.id as GenreId));

  // Close dropdown on outside click
  useEffect(() => {
    if (!dropdownOpen) return;

    const handleClickOutside = (e: MouseEvent) => {
      if (containerRef.current && !containerRef.current.contains(e.target as Node)) {
        setDropdownOpen(false);
      }
    };

    document.addEventListener('mousedown', handleClickOutside);
    return () => document.removeEventListener('mousedown', handleClickOutside);
  }, [dropdownOpen]);

  // Close dropdown on Escape
  useEffect(() => {
    if (!dropdownOpen) return;

    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.key === 'Escape') {
        setDropdownOpen(false);
      }
    };

    document.addEventListener('keydown', handleKeyDown);
    return () => document.removeEventListener('keydown', handleKeyDown);
  }, [dropdownOpen]);

  const handleAddGenre = (genreId: GenreId) => {
    onEnableGenre(genreId);
    // Keep dropdown open for multi-select
  };

  const handleRemoveGenre = (genreId: GenreId) => {
    onDisableGenre(genreId);
  };

  const isFiltering = enabledGenres.size < GENRE_LIST.length;

  return (
    <div className="genre-filter-container" ref={containerRef}>
      {/* Enabled genre chips with X buttons */}
      <div className="genre-filter-chips">
        {enabledGenreList.map(genre => (
          <button
            key={genre.id}
            className="genre-chip-removable"
            onClick={() => handleRemoveGenre(genre.id as GenreId)}
            title={`Remove ${genre.name}`}
          >
            <span className="genre-chip-label">{genre.name}</span>
            <span className="genre-chip-remove material-symbols-outlined">close</span>
          </button>
        ))}

        {/* Dropdown trigger - only show if there are disabled genres to add */}
        {disabledGenres.length > 0 && (
          <button
            className={`genre-add-trigger ${dropdownOpen ? 'active' : ''}`}
            onClick={() => setDropdownOpen(!dropdownOpen)}
            title="Add genre filter"
          >
            <span className="material-symbols-outlined">add</span>
          </button>
        )}

        {/* Reset button - only show when filtering */}
        {isFiltering && (
          <button
            className="genre-reset-btn"
            onClick={onEnableAll}
            title="Show all genres"
          >
            Reset
          </button>
        )}
      </div>

      {/* Dropdown menu */}
      {dropdownOpen && disabledGenres.length > 0 && (
        <div className="genre-dropdown">
          <div className="genre-dropdown-header">Add Genre</div>
          {disabledGenres.map(genre => (
            <button
              key={genre.id}
              className="genre-dropdown-item"
              onClick={() => handleAddGenre(genre.id as GenreId)}
            >
              {genre.name}
            </button>
          ))}
        </div>
      )}
    </div>
  );
}
```

Add CSS styles to `src/App.css`:

```css
/* Genre Filter Container */
.genre-filter-container {
  position: relative;
  display: flex;
  align-items: center;
  gap: 8px;
}

.genre-filter-chips {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  align-items: center;
}

/* Removable genre chip (rounded, with X) */
.genre-chip-removable {
  display: inline-flex;
  align-items: center;
  gap: 6px;
  background: rgba(255, 255, 255, 0.1);
  border: 1px solid rgba(255, 255, 255, 0.15);
  border-radius: 16px;
  color: rgba(255, 255, 255, 0.9);
  font-size: 12px;
  font-weight: 500;
  padding: 6px 8px 6px 14px;
  cursor: pointer;
  transition: all 0.15s ease;
}

.genre-chip-removable:hover {
  background: rgba(255, 255, 255, 0.15);
  border-color: rgba(255, 255, 255, 0.25);
}

.genre-chip-label {
  white-space: nowrap;
}

.genre-chip-remove {
  font-size: 14px;
  color: rgba(255, 255, 255, 0.5);
  transition: color 0.15s ease;
}

.genre-chip-removable:hover .genre-chip-remove {
  color: rgba(255, 255, 255, 0.9);
}

/* Add genre trigger button */
.genre-add-trigger {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 32px;
  height: 32px;
  background: rgba(255, 255, 255, 0.1);
  border: 1px solid rgba(255, 255, 255, 0.15);
  border-radius: 16px;
  color: rgba(255, 255, 255, 0.7);
  cursor: pointer;
  transition: all 0.15s ease;
}

.genre-add-trigger:hover,
.genre-add-trigger.active {
  background: rgba(255, 255, 255, 0.2);
  color: white;
}

.genre-add-trigger .material-symbols-outlined {
  font-size: 18px;
}

/* Reset button */
.genre-reset-btn {
  background: transparent;
  border: none;
  color: rgba(255, 255, 255, 0.5);
  font-size: 12px;
  font-weight: 500;
  padding: 6px 12px;
  cursor: pointer;
  transition: color 0.15s ease;
}

.genre-reset-btn:hover {
  color: rgba(255, 255, 255, 0.9);
}

/* Dropdown menu */
.genre-dropdown {
  position: absolute;
  top: 100%;
  left: 0;
  margin-top: 8px;
  background: rgba(0, 0, 0, 0.9);
  backdrop-filter: blur(20px);
  -webkit-backdrop-filter: blur(20px);
  border: 1px solid rgba(255, 255, 255, 0.1);
  border-radius: 12px;
  padding: 8px 0;
  min-width: 180px;
  z-index: 200;
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
}

.genre-dropdown-header {
  padding: 8px 16px;
  font-size: 11px;
  font-weight: 600;
  color: rgba(255, 255, 255, 0.5);
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.genre-dropdown-item {
  display: block;
  width: 100%;
  padding: 10px 16px;
  background: transparent;
  border: none;
  color: rgba(255, 255, 255, 0.9);
  font-size: 14px;
  text-align: left;
  cursor: pointer;
  transition: background 0.15s ease;
}

.genre-dropdown-item:hover {
  background: rgba(255, 255, 255, 0.1);
}
```
  </action>
  <verify>
    - `npm run build` succeeds without errors
    - `npm run lint` passes
    - File exists: src/components/GenreFilter.tsx
    - CSS styles added to App.css
  </verify>
  <done>
    - GenreFilter component with dropdown multi-select
    - Enabled genres shown as rounded chips with X button
    - Clicking X removes genre (filters out those stations)
    - Add button opens dropdown to re-enable genres
    - Reset button to show all genres
  </done>
</task>

<task type="auto">
  <name>Task 4: Integrate filtering into App.tsx</name>
  <files>
    src/App.tsx (modify)
  </files>
  <action>
Update App.tsx to add genre filtering:

1. **Add imports:**
```typescript
import GenreFilter from './components/GenreFilter'
import { useGenreFilter } from './hooks'
import { filterChannelsByGenre } from './utils'
```

2. **Add filter hook:**
After `const { isFavorite, toggleFavorite } = useFavorites()`:
```typescript
const {
  enabledGenres,
  enableGenre,
  disableGenre,
  enableAll,
  isFiltering,
  enabledCount,
} = useGenreFilter();
```

3. **Update sortedChannels to include filtering:**
Change:
```typescript
const sortedChannels = useMemo(() => {
  return sortChannels(channels, sortOption)
}, [channels, sortOption])
```
To:
```typescript
const filteredChannels = useMemo(() => {
  return filterChannelsByGenre(channels, enabledGenres);
}, [channels, enabledGenres]);

const sortedChannels = useMemo(() => {
  return sortChannels(filteredChannels, sortOption);
}, [filteredChannels, sortOption]);
```

4. **Add GenreFilter component in the header area:**
Find the section with sorting/count display and add GenreFilter. Place it in a logical location, perhaps in a new filter row or alongside existing controls:

```tsx
{/* Genre Filter - show when content visible */}
{contentVisible && (
  <div className="genre-filter-row">
    <GenreFilter
      enabledGenres={enabledGenres}
      onEnableGenre={enableGenre}
      onDisableGenre={disableGenre}
      onEnableAll={enableAll}
    />
  </div>
)}
```

5. **Add CSS for filter row positioning** to App.css:
```css
/* Genre filter row */
.genre-filter-row {
  position: fixed;
  top: 20px;
  left: 20px;
  z-index: 100;
  max-width: calc(100vw - 200px);
}
```

6. **Update station count to show filtered state:**
```tsx
{isLoading ? 'Loading stations...' :
  sortedChannels.length > 0
    ? `${sortedChannels.length} stations${isFiltering ? ' (filtered)' : ''}`
    : enabledCount === 0
      ? 'No genres selected'
      : 'No stations available'}
```
  </action>
  <verify>
    - `npm run build` succeeds without errors
    - `npm run lint` passes
    - GenreFilter appears when content is visible
    - Filtering actually removes channels from carousel/picker
    - Station count shows "(filtered)" when filtering
  </verify>
  <done>
    - Genre filter integrated into App.tsx
    - Filter state flows through to sortedChannels
    - Station count indicates when filtering is active
  </done>
</task>

<task type="auto">
  <name>Task 5: Handle empty state and edge cases</name>
  <files>
    src/App.tsx (modify)
  </files>
  <action>
1. **Handle selection when current channel is filtered out:**
The current audio keeps playing even if the selected channel is filtered out - this is intentional UX. The carousel just won't highlight it.

2. **Handle empty filter state gracefully:**
When all genres are disabled:
- Show "No genres selected" message
- Carousel shows empty state
- Reset button is visible to restore all

3. **Ensure responsive behavior:**
Add media query for mobile:
```css
@media (max-width: 768px) {
  .genre-filter-row {
    top: 70px;
    left: 10px;
    right: 10px;
    max-width: none;
  }

  .genre-filter-chips {
    max-width: 100%;
    overflow-x: auto;
    flex-wrap: nowrap;
    padding-bottom: 4px;
  }

  .genre-dropdown {
    position: fixed;
    left: 10px;
    right: 10px;
    width: auto;
  }
}
```
  </action>
  <verify>
    - `npm run build` succeeds without errors
    - `npm run lint` passes
    - App handles empty filter state gracefully
    - Responsive layout works on mobile
  </verify>
  <done>
    - Empty state handled with clear messaging
    - Responsive design for mobile
    - Edge cases covered
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Genre filtering with dropdown multi-select and removable chips</what-built>
  <how-to-verify>
    1. Run: `npm run dev` in the Tuner directory
    2. Open: http://localhost:5173
    3. Wait for splash screen to finish
    4. Look for genre chips in top-left area (all 8 genres shown as chips)
    5. Click the X on any chip to remove that genre - stations should filter
    6. Click the + button to see dropdown of removed genres
    7. Select a genre from dropdown to add it back
    8. Click "Reset" to restore all genres
    9. Verify station count shows "(filtered)" when not all genres selected
    10. Reload page - filter state should persist
    11. Test on mobile viewport - chips should scroll horizontally
  </how-to-verify>
  <resume-signal>Type "approved" if genre filtering works correctly, or describe any issues</resume-signal>
</task>
</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds without errors
- [ ] `npm run lint` passes
- [ ] useGenreFilter hook exists and persists to localStorage
- [ ] Genre mapping utility correctly maps channels to GenreId
- [ ] GenreFilter component shows chips with X buttons
- [ ] Dropdown appears when clicking + button
- [ ] Filtering actually removes channels from carousel/picker
- [ ] Reset button restores all genres
- [ ] Filter state persists across page reloads
</verification>

<success_criteria>
- Dropdown multi-select for picking genres
- All genres ON by default
- Enabled genres displayed as rounded chips with X button
- Clicking X removes genre and filters stations
- Reset button to show all genres
- localStorage persistence
- Responsive design
- Matches existing `.filter-chip` styling
</success_criteria>

<output>
After completion, create `.planning/phases/08-genre-filtering/08-01-SUMMARY.md` using the summary template.
</output>
