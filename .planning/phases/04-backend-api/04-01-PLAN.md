# Phase 4 Plan 1: Backend API Organization

## Objective

Create `/api/channels` endpoint in the Express server that returns all channels organized by genre (default) or by source, loading configuration from the TypeScript source registry at server startup.

## Execution Context

**Subsystem:** backend
**Requires:** Phase 3 (Radio Paradise proxy), Phase 2 (source registry), Phase 1 (genre taxonomy)
**Provides:** [channels-api-endpoint, genre-view, source-view]
**Affects:** Phase 6 (Genre Panel), Phase 7 (View Toggle)
**Tags:** express, api, typescript, data-organization
**Estimated scope:** Small (5 tasks, ~45 min)

## Context

### Available From Prior Phases

- **Phase 1:** Genre taxonomy with 8 categories (`GenreId` type, `GENRES` object, `getGenre()`, `GENRE_LIST`)
- **Phase 2:** Source registry with 53 channel definitions across 2 sources
  - `getAllChannelDefinitions()` returns `ChannelDefinitionWithSource[]`
  - `getAllChannelMappings()` returns `ChannelMappingWithSource[]`
  - Each mapping has `channelId`, `primaryGenre`, `secondaryGenres?`, `sourceId`
- **Phase 3:** Radio Paradise proxy endpoints working in `server/index.js`

### Current Server State

The server at `/Users/neileverette/Desktop/Tuner/server/index.js` is JavaScript (not TypeScript). It has:
- Express with CORS enabled
- SomaFM stream proxy at `/api/stream/:channelId`
- Radio Paradise stream proxy at `/api/rp/stream/:channelId/:format`
- Radio Paradise now-playing proxy at `/api/rp/now-playing/:chan`

### Key Challenge

The config files are TypeScript in `src/config/`, but the server is JavaScript. We have two options:
1. **Build step:** Compile TS config, import from dist in server
2. **Duplicate data:** Re-export config as JSON or JS module for server

**Decision:** Use build step approach - compile TypeScript config to JS, import in server. This keeps the source of truth in TypeScript while enabling server consumption.

### API Response Shapes

```typescript
// Genre view (default) - channels grouped by genre
interface GenreViewResponse {
  view: 'genre';
  genres: Array<{
    id: string;           // GenreId
    name: string;         // Display name
    channels: ApiChannel[];
  }>;
}

// Source view - channels grouped by source, then genre
interface SourceViewResponse {
  view: 'source';
  sources: Array<{
    id: string;           // Source ID
    name: string;         // Display name (e.g., "SomaFM")
    genres: Array<{
      id: string;
      name: string;
      channels: ApiChannel[];
    }>;
  }>;
}

// Channel in API response
interface ApiChannel {
  id: string;             // Channel ID
  source: string;         // Source ID
  title: string;
  description: string;
  image: string;          // Medium image URL
  homepage: string | null;
  genres: string[];       // All genres (primary + secondary)
}
```

## Tasks

### Task 1: Create API response type definitions

**File:** `src/config/api-types.ts`

Define TypeScript interfaces for the API response shapes. These types will be:
1. Used by the build process to type-check the aggregation logic
2. Importable by frontend for type-safe API consumption

```typescript
// Types to define:
// - ApiChannel (channel in response)
// - GenreGroup (genre with its channels)
// - SourceGroup (source with its genres and channels)
// - GenreViewResponse
// - SourceViewResponse
// - ChannelsApiResponse (union of both views)
```

**Verification:** `npx tsc --noEmit src/config/api-types.ts`

---

### Task 2: Create channel aggregation utilities

**File:** `src/config/aggregation.ts`

Implement functions that transform the source registry data into API response shapes:

```typescript
// Function: aggregateByGenre()
// - Iterate GENRE_LIST for consistent ordering
// - For each genre, collect channels where genre is primary OR in secondaryGenres
// - Transform ChannelDefinitionWithSource to ApiChannel format
// - Return GenreViewResponse

// Function: aggregateBySource()
// - Iterate SOURCES for consistent ordering
// - For each source, group its channels by primaryGenre
// - Include channel in secondary genre groups as well
// - Return SourceViewResponse
```

**Verification:** TypeScript compiles without errors

---

### Task 3: Add build script for server config

**Files:**
- `package.json` (add script)
- `tsconfig.server.json` (new config for server-consumable output)

Create a build configuration that:
1. Compiles `src/config/*.ts` to `dist/config/` as CommonJS modules
2. Allows `server/index.js` to `require()` the compiled output

Add npm script: `"build:config": "tsc -p tsconfig.server.json"`

**Verification:** `npm run build:config` succeeds, `dist/config/` contains JS files

---

### Task 4: Implement /api/channels endpoint

**File:** `server/index.js`

Add the channels endpoint that:
1. Imports compiled aggregation functions from `../dist/config/aggregation`
2. Reads `view` query parameter (default: 'genre')
3. Calls appropriate aggregation function
4. Returns JSON response with correct shape

```javascript
// Route: GET /api/channels?view=genre|source
app.get('/api/channels', (req, res) => {
  const view = req.query.view || 'genre';
  // ... aggregation and response
});
```

**Verification:**
- `curl http://localhost:3001/api/channels` returns genre view
- `curl http://localhost:3001/api/channels?view=source` returns source view

---

### Task 5: End-to-end verification and documentation

Verify the complete API:
1. Start server with `npm run dev` (or similar)
2. Test both view modes return valid JSON
3. Verify channel counts (53 total across both views)
4. Verify genre grouping includes channels with secondary genres
5. Document API in a brief comment block in server/index.js

**Verification checklist:**
- [ ] Genre view returns 8 genres with channels
- [ ] Source view returns 2 sources (somafm, radio-paradise)
- [ ] Channels appear in multiple genres when they have secondaryGenres
- [ ] Response shapes match TypeScript interfaces

## Checkpoints

| After Task | Verify | Rollback |
|------------|--------|----------|
| 1 | TS compiles | Delete api-types.ts |
| 2 | TS compiles, aggregation functions exist | Delete aggregation.ts |
| 3 | `npm run build:config` works | Remove tsconfig.server.json, revert package.json |
| 4 | API endpoint returns data | Revert server/index.js changes |
| 5 | All verification items pass | - |

## Verification

```bash
# After all tasks complete:

# 1. Build config
npm run build:config

# 2. Start server (in separate terminal)
node server/index.js

# 3. Test genre view (default)
curl -s http://localhost:3001/api/channels | jq '.view, .genres | length'
# Expected: "genre", 8

# 4. Test source view
curl -s http://localhost:3001/api/channels?view=source | jq '.view, .sources | length'
# Expected: "source", 2

# 5. Verify channel count in genre view
curl -s http://localhost:3001/api/channels | jq '[.genres[].channels[]] | length'
# Expected: >= 53 (channels appear in multiple genres)

# 6. Verify SomaFM proxy still works (regression)
curl -s -o /dev/null -w "%{http_code}" http://localhost:3001/api/stream/groovesalad
# Expected: 200
```

## Success Criteria

- [ ] `/api/channels` endpoint exists and returns JSON
- [ ] `?view=genre` (default) returns channels grouped by 8 genres
- [ ] `?view=source` returns channels grouped by 2 sources, then by genre
- [ ] Response includes all 53 channels (some duplicated across genres)
- [ ] TypeScript types defined for API response shapes
- [ ] Build script compiles config for server consumption
- [ ] Existing proxy endpoints continue to work (no regression)

## Output

### Files Created
- `src/config/api-types.ts` - API response type definitions
- `src/config/aggregation.ts` - Channel aggregation utilities
- `tsconfig.server.json` - Build config for server-consumable output
- `dist/config/*.js` - Compiled config (gitignored)

### Files Modified
- `server/index.js` - Added /api/channels endpoint
- `package.json` - Added build:config script

### Dependencies Unlocked
- Phase 6 (Genre Panel) - can now consume /api/channels?view=genre
- Phase 7 (View Toggle) - can switch between view modes

---
*Created: 2026-01-19*
